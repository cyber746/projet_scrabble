import time
import random as rd #modif
import numpy as np
import copy as copy #modif

txt = open( "/Users/yoannloday/Documents/Scrabble/ods8.txt" , "r") #ods8 ajouté
l = txt.readlines()
ods8 = []
for s in l:
    ods8.append(s[0:len(s)-1])

class GaddagNode:
	"""Classe de noeuds constituant le gaddag"""
	def __init__(self, id):
		self.id = id
		self.possibles = ""
		self.edges = {}

	def __str__(self):
		str_list = [self.possibles]
		for (label, node) in self.edges.items():
			str_list.append(label)
			str_list.append(str(node.id))
		return '_'.join(str_list)

	def __hash__(self):
		return self.__str__().__hash__()

	def __eq__(self, autre):
		return self.__str__() == autre.__str__()

	def copy(self):
		new_node = GaddagNode(self.id)
		new_node.possibles = self.possibles
		new_node.edges = self.edges
		return new_node

class Gaddag:
	"""Classe du gaddag (cf article pour son principe)"""
	compteurNodes = 0
	def __init__(self):
		self.root = GaddagNode(Gaddag.compteurNodes)
		self.mot_precedent = ""
		self.a_verifier = []
		self.Node_minimises = {}
		self.Node_list = []
		Gaddag.compteurNodes += 1

	def inserer(self, mot):
		"""routine d'insertion des mots dans le gaddag (cf. article)"""
		if mot <= self.mot_precedent:
			raise Exception("Erreur: les mots doivent être insérés dans l'ordre alphabétique")
		prefixe_commun = 0
		for i in range(min(len(mot), len(self.mot_precedent))):
			if mot[i] != self.mot_precedent[i]:
				break
			prefixe_commun += 1

		if len(self.mot_precedent) == prefixe_commun and self.mot_precedent != "":
			prefixe_commun -= 1

		self.minimize(prefixe_commun)

		if len(self.a_verifier) == 0:
			node = self.root
		else:
			node = self.a_verifier[-1][2]

		for lettre in mot[prefixe_commun:len(mot)-1]:
			node_suivant = GaddagNode(Gaddag.compteurNodes)
			Gaddag.compteurNodes += 1
			node.edges[lettre] = node_suivant
			self.a_verifier.append((node, lettre, node_suivant))
			node = node_suivant

		node.possibles =''.join(sorted(node.possibles+mot[-1]))
		self.mot_precedent = mot

	def termine(self):
		"""routine terminant la simplification du gaddag quand le dernier mot est ajouté"""
		self.minimize(0)
		self.Node_minimises[self.root] = self.root
		self.renumber()

	def renumber(self):
		"""routine de redéfinition des labels des noeuds"""
		node_list = []
		id_map = {}
		def ajoute_node_list(node):
			if str(node.id) in id_map.keys():
				return
			node_list.append(node)
			id_map[str(node.id)] = len(id_map)
			for label, fils in node.edges.items():
				ajoute_node_list(fils)
		ajoute_node_list(self.root)
		for i in range(len(node_list)):
			node = node_list[i].copy()
			for label, fils in node.edges.items():
				node.edges[label] = id_map[str(fils.id)]
			node_list[i] = node
		for i in range(len(node_list)):
			node_list[i].id = id_map[str(node_list[i].id)]
		self.Node_list = node_list

	def minimize(self, ind_reduc):
		"""routine de minimisation du gaddag par recherche de noeuds identiques"""
		for i in range(len(self.a_verifier)-1, ind_reduc-1, -1):
			(parent, lettre, fils) = self.a_verifier[i]
			if fils in self.Node_minimises:
				parent.edges[lettre] = self.Node_minimises[fils]
			else:
				self.Node_minimises[fils] = fils
			self.a_verifier.pop()

	def parcours(self, node, pile):
		"""routine de parcours de l'arbre à partir d'un noeud donné et d'un chemin à suivre (donné sous forme de pile)"""
		while pile:
			lettre = pile.pop()
			if (node is None or not(lettre in node.edges)): return None #jsp comment fonctionne try mais ça marche pas -> modifié
            else : node = self.Node_list[node.edges[lettre]] # modif pour renvoyer noeud et pas int
		return node

	def parcours_list(self, index, pile):
		"""routine de parcours de l'arbre quand il est sous forme de liste (à tester)"""
		while pile:
			lettre = pile.pop()
			try:
				index = self.Node_list[index][lettre]
			except KeyError:
				return None
		return self.Node_list[index]

	def cherche(self, mot):
		"""routine de recherche d'un mot dans l'arbre"""
		node = self.root
		pile = list(mot)
		lettre1 = pile.pop(0)
		node = self.parcours(node, pile)
		return lettre1 in node.possibles

	def cherche_list(self, mot):
		"""routine de recherche d'un mot dans l'arbre quand il a été mis sous forme de liste (à tester)"""
		pile = list(mot)
		lettre1 = pile.pop(0)
		node = self.parcours_list(0, pile)
		return lettre1 in node.possibles

	def anagram_list(self, tirage):
		"""routine de recherche d'anagramme (à faire)"""
		pass


	def pivot(self, pref2, suff2): #modif
		"""routine de recherche des pivots"""
		pref, suff = pref2.upper(),suff2.upper() #modif
		node = self.root
		if len(suff) >= len(pref):
			pile = list(suff)
			node = self.parcours(node, pile)
			if node is None:
				return ""
			if pref == "":
				return node.possibles
			else:
				possibles = ""
				for char in node.edges.keys():
					node_test = self.parcours(node, list(pref[1:]+char))
					if node_test is not None and pref[0] in node_test.possibles and char!="!":
						possibles += char
				return possibles
		else:
			pile = list(reversed(pref))
			pile.insert(-1, "!")
			node = self.parcours(node, pile)
			if node is None:
				return ""
			if suff == "":
				return node.possibles
			else:
				possibles = ""
				for char in node.edges.keys():
					node_test = self.parcours(node, list(reversed(char+suff[:-1])))
					if node_test is not None and suff[-1] in node_test.possibles:
						possibles += char
				return possibles


	def pivot2(self, pref, suff): # à modifier (lowercase)
		"""routine de recherche des pivots, simple mais pas opti"""
		pivot_possible = ""
		for char in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
			if self.cherche(pref+char+suff):
				pivot_possible += char
		return pivot_possible


	def nb_nodes(self):
		"""routine donnant le nombre de noeuds de l'arbre"""
		return len(self.Node_minimises)

	def nb_aretes(self):
		"""routine donnant le nombre d'arètes de l'arbre"""
		compte = 0
		for node in self.Node_minimises:
			compte += len(node.edges)
		return compte

	def exporter(self, filename):
		"""routine d'export de l'arbre : on le met sous forme de liste de noeuds qu'on exporte dans un fichier txt"""
		with open(filename, 'w') as file:
			for node in self.Node_list:
				nodestr = str(node.id) + ',' + node.possibles + ','
				for (label, node_fils) in node.edges.items():
					nodestr += label + str(node_fils) + ','
				file.write(nodestr[:-1] + '\n')
		return('Fichier créé')

	def display(self):
		"""routine d'affichage de l'arbre; Éviter d'utiliser sur un arbre gros..."""
		pile = [self.root]
		finis = set()
		while pile:
			node = pile.pop()
			if node.id in finis:
				continue
			finis.add(node.id)
			print("{}: {}".format(node.id, node))
			if len(node.possibles)>0:
				print('    ('+node.possibles+')')
			for label, fils in node.edges.items():
				print("    {} vers {}".format(label, fils.id))
				pile.append(fils)

def importer(self, filename):
	"""routine d'import d'un fichier de noeuds et de construction du gaddag résultant mis sous forme de liste"""
	dico = Gaddag()
	with open(filename) as file:
		for line in file:
			node_list = line.strip().split(',')
			new_node = GaddagNode(int(node_list.pop(0)))
			new_node.possibles = node_list.pop(0)
			new_node.edges = dict()
			if node_list:
				for elt in node_list:
					new_node.edges[elt[0]] = int(elt[1:])
			dico.Node_list.append(new_node)
	print('Fichier importé')
	return dico

def build_dic():
	"""routine de contruction du gaddag à partir d'un fichier txt de mots"""
	start = time.time()
	gaddag = Gaddag()
	mots = []
	with open('/Users/yoannloday/Documents/Scrabble/crabbods8.txt') as file:
		for ligne in file:
			mot = ligne.strip()
			mots.append(mot[::-1])
			for i in range(len(mot)-1):
				mots.append(mot[i::-1]+'!'+mot[i+1:])
		print("Liste terminée en {0}s".format(time.time()-start))
		for mot in sorted(mots):
			gaddag.inserer(mot)
		print("Mots insérés en {0}s".format(time.time()-start))
		gaddag.termine()
		print("Création du gaddag en {0}s".format(time.time()-start))
	return gaddag

def refcoord(ref):
    if len(ref)==2:
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            return ord(ref[0])-ord('A') , int(ref[1])-1, 'h'
        else:
            return ord(ref[1])-ord('A') , int(ref[0])-1, 'v'
    else:
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            return  ord(ref[0])-ord('A') , int(ref[1:])-1, 'h'
        else:
            return ord(ref[2])-ord('A') , int(ref[:2])-1, 'v'

def coordref(coord,direction):
    (i,j) = coord
    if direction == 'h': return chr(ord('A')+i)+str(j+1)
    else: return str(j+1)+chr(ord('A')+i)

##

class Grille:
	"""Classe construisant la grille de jeu"""
	def __init__(self, taille, bonus):
		self.taille = taille
		self.jetons = []
		self.bonus = bonus
# j'ai trafiqué get_multiplicateur qui marchait pas, modif
    #self.mult_mot = get_multiplicateur('M')
		gm = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if 'M' in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			gm.append(l)
        self.mult_mot = gm
    #self.mult_lettre = get_multiplicateur('L')
		gl = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if 'L' in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			gl.append(l)
        self.mult_lettre = gl
		for i in range(taille):
			ligne = []
			for j in range(taille):
				ligne.append(None)
			self.jetons.append(ligne)

	def __str__(self):
		return '\n'.join(''.join(x if x is not None else '_' for x in ligne) for ligne in self.jetons)

    def __print__(self): #ajout (on critique pas la qualité)
        for i in range(15):
            s = ""
            for j in range(15):
                if self.est_occupe((i,j)): s+=self.get_jeton((i,j))
                else : s+= " "
            print(s)

	def coord_cases(self):
		liste_coord = []
		for ligne in range(self.taille):
			for col in range(self.taille):
				liste_coord.append((ligne, col))
		return liste_coord

	def get_jeton(self, pos):
		ligne, col = pos
		return self.jetons[ligne][col]

	def set_jeton(self, pos, jeton):
		ligne, col = pos
		self.jetons[ligne][col] = jeton

    def placer_mot(self, ref, mot): #modif
        ligne, col = refcoord(ref)[:2]
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            for k in range(len(mot)):
                self.set_jeton((ligne , col + k), mot[k])
        else:
            for k in range(len(mot)):
                self.set_jeton((ligne + k, col), mot[k])

	def check_limites(self, pos):
		ligne, col = pos
		return ligne >= 0 and ligne < self.taille and col >= 0 and col < self.taille

	def est_vide(self, pos):
		return self.check_limites(pos) and self.get_jeton(pos) is None

	def est_occupe(self, pos):
		return self.check_limites(pos) and self.get_jeton(pos) is not None

	def copy(self):
		resultat = Grille(self.taille, self.bonus)
		for pos in self.coord_cases():
			resultat.set_jeton(pos, self.get_jeton(pos))
		return resultat

	def get_multiplicateur(self, char): #sert plus à rien
		g = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if char in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			g.append(l)
		return g

def grille_test(src):
	"""routine de construction de la grille à partir d'un fichier de paramètres comme celui fourni"""
	bonus = []
	with open(src, 'r') as g_txt:
			taille = int(g_txt.readline().strip())
			for line in g_txt:
				ligne = line.strip().split(',')
				if len(ligne) != taille:
					return('Erreur dans le fichier de paramètres de la grille')
				else:
					bonus.append(ligne)
	return(Grille(taille, bonus))

# g = grille_test('/Users/yoannloday/Documents/Scrabble/Python/grille.txt')

V = { "A": 1, "B" : 3, "C" : 3, "D" : 2, "E" : 1, "F" : 4, "G" : 2, "H" : 4, "I" : 1, "J" : 8, "K" : 10, "L" : 1, "M" : 2, "N" : 1, "O" : 1, "P" : 3, "Q" : 8, "R" : 1, "S" : 1, "T" : 1, "U" : 1, "V" : 4, "W" : 10, "X" : 10, "Y" : 10, "Z" : 10, "?" : 0 }

P = {0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:50,8:75,9:100,10:125}

R = list("??AAAAAAAAABBCCDDDEEEEEEEEEEEEEEEFFGGHHIIIIIIIIJKLLLLLMMMNNNNNNOOOOOOPPQRRRRRRSSSSSSTTTTTTUUUUUUVVWXYZ")

##
#from dico_gaddag import build_dic
#from grille import grille_test

#import time

class Solveur:
	"""Classe qui calcule le meilleur coup sur une grille donnée selon un tirage et un dico donnés"""
	def __init__(self, dico, grille, chevalet, valeurs, primes, nb_lettres_autorisees): #modif
		self.dico = dico
		self.grille = grille
		self.chevalet = chevalet
		self.valeurs = valeurs
		self.primes = primes
		self.nb_lettres_interdites = max(0 , len(chevalet) - nb_lettres_autorisees) #modif
		self.pivot = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.pref = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.suff = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.score_pivot = [[{'v':0,'h':0} for _ in range(grille.taille)] for _ in range(grille.taille)] #modif pour résoudre KeyError
		self.ancres = []
		self.trouves = []

	def avant(self, pos, direction):
		"""retourne la case avant pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col-1
		else:
			return ligne-1, col

	def apres(self, pos, direction):
		"""retourne la case après pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col+1
		else:
			return ligne+1, col

	def shift(self, pos, shift, direction):
		"""retourne la case shiftée de shift cases par rapport à pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col+shift
		else:
			return ligne+shift, col

	def trouve_ancres(self):
		"""retourne les ancres (cases adjacentes à des jetons déjà sur la grille ou case centrale si grille vide)"""
		ancres = []
		for pos in self.grille.coord_cases():
			vide = self.grille.est_vide(pos)
			voisins_occupes = self.grille.est_occupe(self.avant(pos,'h')) or self.grille.est_occupe(self.apres(pos,'h')) or self.grille.est_occupe(self.avant(pos,'v')) or self.grille.est_occupe(self.apres(pos,'v'))
			if vide and voisins_occupes:
				ancres.append(pos)
		if not ancres:
			ancres.append((7,7)) #à adapter plus tard
		self.ancres = ancres

	def update_pivot(self):
		"""Calcule les pivots suivant la grille donnée"""
		for pos in self.ancres:
			for direction in ['h', 'v']:
				pref, suff = "", ""
				pos_test = self.avant(pos, direction)
				while self.grille.est_occupe(pos_test):
					pref = self.grille.get_jeton(pos_test) + pref
					pos_test = self.avant(pos_test, direction)

				pos_test = self.apres(pos, direction)
				while self.grille.est_occupe(pos_test):
					suff = suff + self.grille.get_jeton(pos_test)
					pos_test = self.apres(pos_test, direction)

				ligne, col = pos
				if pref or suff:
					self.pivot[ligne][col][direction] = self.dico.pivot(pref, suff)
					self.pref[ligne][col][direction] = pref
					self.suff[ligne][col][direction] = suff
					self.score_pivot[ligne][col][direction] = self.compte_pivot(ligne, col, direction, pref+suff)

	def compte_pivot(self, ligne, col, direction, seq):
		"""Compte les mots en pivot"""
		compte = 0
		for lettre in seq:
			try:
				compte += self.valeurs[lettre]
			except KeyError:
				pass
		return compte

	def get_valeur(self, lettre):
		"""Retourne la valeur d'une lettre"""
		try:
			return self.valeurs[lettre]
		except KeyError:
			return 0

	def cherche(self):
		"""Cherche tous les coups possibles en parcourant toutes les ancres"""
		start = time.time()
		self.trouve_ancres()
		self.update_pivot()
		for ancre in self.ancres:
			for direction in ['h','v']:
				try:
					suff = self.suff[ancre[0]][ancre[1]][direction]
					node = self.dico.parcours(self.dico.root, list(suff.upper()))
				except KeyError:
					suff = ''
					node = self.dico.root
				chevalet = [x for x in self.chevalet]
				self.generer_coups(ancre, 0, direction, suff, chevalet, node)
#		print("Recherche faite en {0}s".format(time.time()-start))

	def autorises(self, pos, direction):
		"""Retourne toutes les lettres autorisées sur une case pos"""
		ligne, col = pos
		if not(0 <= ligne < 15 and 0 <= col < 15): return "" #modif (try marche pas ?)
		else: # modif
            try:
                return self.pivot[ligne][col][direction]
            except KeyError:
                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	def generer_coups(self, pos_ancre, shift, direction, mot, chevalet, node):
#	    print(shift,mot)
		"""Pour une ancre donnée, essaye toutes les lettres possibles selon le dico (première routine de l'article)"""
		pos_scan = self.shift(pos_ancre, shift, direction)
		if direction == 'h':
			direction_perp = 'v'
		else:
			direction_perp = 'h'
		if self.grille.est_occupe(pos_scan):
			lettre = self.grille.get_jeton(pos_scan)
#			self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
            if lettre == lettre.upper(): self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
            else: self.aller_a(pos_ancre, shift, direction, lettre.upper(), mot, chevalet, node, True)
		elif len(chevalet) > self.nb_lettres_interdites: #modif
			for lettre in set(chevalet.copy()):
				if lettre in self.autorises(pos_scan, direction_perp):
					chevalet.remove(lettre)
					self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
					chevalet.append(lettre)
			if '?' in chevalet:
				for lettre in self.autorises(pos_scan, direction_perp):
					chevalet.remove('?')
					self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, True)
					chevalet.append('?')

	def aller_a(self, pos_ancre, shift, direction, lettre, mot, chevalet, node, est_jok):
		"""Une fois la lettre posée, teste toutes les cases sur lesquelles on peut continuer la recherche (deuxième routine de l'article)"""
		pos_scan = self.shift(pos_ancre, shift, direction)
		if shift <= 0:
			mot = lettre + mot
			if est_jok:
				mot = mot[:1].lower() + mot[1:]
			if node is not None and lettre in node.possibles and not self.grille.est_occupe(self.avant(pos_scan, direction)):
				self.enregistre(pos_scan, direction, mot)
			node = self.dico.parcours(node, [lettre])
			if node is not None:
				pos_scan = self.avant(pos_scan, direction)
				if pos_scan not in self.ancres: #and self.grille.check_limites(pos_scan): # pas modif
					self.generer_coups(pos_ancre, shift-1, direction, mot, chevalet, node)
				node = self.dico.parcours(node, ['!'])
				try:
					shift_apres = len(self.suff[pos_ancre[0]][pos_ancre[1]][direction]) + 1
				except KeyError:
					shift_apres = 1
				if node is not None and not self.grille.est_occupe(pos_scan):
					self.generer_coups(pos_ancre, shift_apres, direction, mot, chevalet, node)
		else:
			mot = mot + lettre
			if est_jok:
				mot = mot[:-1] + mot[-1].lower()
			if node is not None and lettre in node.possibles and not self.grille.est_occupe(self.apres(pos_scan, direction)):
				self.enregistre(self.shift(pos_scan, -len(mot)+1, direction), direction, mot)
			node = self.dico.parcours(node, [lettre])
			if node is not None: #and self.grille.est_vide(self.apres(pos_scan, direction)): #modif
				self.generer_coups(pos_ancre, shift+1, direction, mot, chevalet, node)


    def compte(self, pos, direction, mot):
        """Compte le mot trouvé"""
        c = 0
        nb_lettres_posees = 0
        mult_mot = 1
        pos_scan = pos
        compte_pivot = 0
        if direction == 'h':
            direction_perp = 'v'
        else:
            direction_perp = 'h'
        for lettre in mot:
            valeur_lettre = self.get_valeur(lettre)
            if self.grille.est_occupe(pos_scan):
                c += valeur_lettre
            else:
                nb_lettres_posees += 1
                mult_lettre = self.grille.mult_lettre[pos_scan[0]][pos_scan[1]]
                mult_mot_pivot = self.grille.mult_mot[pos_scan[0]][pos_scan[1]]
                mult_mot *= mult_mot_pivot
                c += valeur_lettre*mult_lettre
                try:
                    compte_pivot_case = self.score_pivot[pos_scan[0]][pos_scan[1]][direction_perp] #à tester pour voir si ça marche avec le None (spoiler ça marche pas)
                except KeyError:
                    compte_pivot_case = 0
                if compte_pivot_case > 0 or (direction_perp in self.pref[pos_scan[0]][pos_scan[1]]) or (direction_perp in self.suff[pos_scan[0]][pos_scan[1]]): #modif (cas ou pivot sur joker)
                    compte_pivot_case += valeur_lettre*mult_lettre
                compte_pivot += mult_mot_pivot*compte_pivot_case
            pos_scan = self.apres(pos_scan, direction)
        return(mult_mot*c + compte_pivot + self.primes[nb_lettres_posees])

	def enregistre(self, pos, direction, mot):
		"""Enregistre un mot trouvé"""
		ref = chr(ord('A')+pos[0])
		if direction == 'h':
			ref += str(pos[1]+1)
		else:
			ref = str(pos[1]+1) + ref
		score = self.compte(pos, direction, mot)
		self.trouves.append((ref, mot, score))

	def tri_solutions(self): #à voir si cette fonction a sa place ici (peut-être dans un futur partie.py ?)
		self.trouves.sort(key = lambda a: (-a[2], a[1]))

    def reliquat(self, ref, mot):
        reliq = list(self.chevalet)
        c,l,direction = refcoord(ref)
        pos_scan = c,l
        for lettre in mot:
            if not(self.grille.est_occupe(pos_scan)):
                if lettre == lettre.upper():
                    for k in range(len(reliq)):
                        if reliq[k] == lettre:
                            reliq.pop(k)
                            break
                else:
                    for k in range(len(reliq)):
                        if reliq[k] == '?':
                            reliq.pop(k)
                            break
            pos_scan = self.apres(pos_scan, direction)
        return reliq




# débuggage et additions
# get multiplicateur définie en dehors (redéfinie dans init)
# parcours qui renvoie un integer et pas un node (modifié le return de parcours)
# compte_pivot_case plante quand direction est pas dans le dictionnaire -> initialisation de score_pivot à {'v':0,'h':0}
# rajouté les 7/8
# pivot sur mot avec joker -> pref et suff en majuscule + suff en maj dans cherche
# pivot "!"

# refcoord grille.print placer_mot reliquat
# à faire : fonction reliquat pour jouer des parties joker

def voy(s):
    m = 0
    for k in s:
        if k in "AEUIO":
            m+=1
    return m

def cons(s):
    m = 0
    for k in s:
        if not(k in "AEUIOY?"):
            m+=1
    return m

def tirage(sac2, reliquat, coup, nb_lettres): #verifier sac>1, voy+y+jok>=1, cons+y+jok>=1
    sac = sac2.copy()
    tirage = reliquat.copy()
    if coup <= 15:
        v,c = min(2,voy(sac+tirage)),min(2,cons(sac+tirage))
        if v>0 and c>0:
            while voy(tirage)<v or cons(tirage)<c or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
        else:
            while not('Y' in tirage or '?' in tirage) or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
    else:
        v,c = min(1,voy(sac+tirage)),min(1,cons(sac+tirage))
        if v>0 and c>0:
            while voy(tirage)<v or cons(tirage)<c or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
        else:
            while not('Y' in tirage or '?' in tirage) or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
    return tirage , sac

def fusion(l):
    s = ""
    for k in l: s+=k
    return s

def Partie(dico, grille, sac2, nb_lettres, valeurs, primes, nb_lettres_autorisees):
    sac = list(sac2)
    l = []
    reliq = []
    total = sac + reliq
    while len(total)>1 and (('Y' in total) or ('?' in total) or (voy(total)>0 and cons(total)>0)):
        t,sac = tirage(sac, reliq, len(l)+1, nb_lettres)
        S = Solveur(dico,grille,fusion(t),valeurs,primes,nb_lettres_autorisees)
        S.cherche()
        S.tri_solutions()
        k=1
        while S.trouves == [] and len(sac)>0 and k<10:
            print(l,t)
            sac,reliq = sorted(sac+t),[]
            t,sac = tirage(sac, reliq, len(l)+1, nb_lettres)
            S = Solveur(dico,grille,fusion(t),valeurs,primes,nb_lettres_autorisees)
            S.cherche()
            S.tri_solutions()
            k+=1
        k=0
        tops = []
        if S.trouves == []: break
        while k<len(S.trouves) and S.trouves[k][2]==S.trouves[0][2]:
            tops.append(S.trouves[k])
            k+=1
        top = rd.choice(tops)
        reliq = S.reliquat(top[0],top[1])
        l.append((fusion(t),top[0],top[1],top[2]))
        grille.placer_mot(top[0],top[1])
        total = sac + reliq
    return l

## INTERFACE
from tkinter import *
import time
# WARNING : LES LIGNES ET COLONNES SONT INVERSEES

# faire bouton suppr
# display : max, (mot), coups, reliquat, top global, négatif global
# chrono



class Interface(Frame): #pourq

    def CaseToMatrix(self, case): #mm chose que refcoord ?
        return (ord(case[0])-ord("A"), int(case[1:])-1)

    def poser(self, lettre, x, y): #ajout
        self.canvas.create_rectangle(x,y,x+40,y+40,fill="gold")
        if lettre == lettre.upper():
            self.lettre = self.canvas.create_text(x+20, y+20, text=lettre,  font=("Helvetica", 30), tags="lettre")
            if V[lettre]<10: self.valeur = self.canvas.create_text(x+35, y+34, text=V[lettre],  font=("Helvetica", 12), tags="lettre")
            else: self.valeur = self.canvas.create_text(x+32, y+34, text=V[lettre],  font=("Helvetica", 12), tags="lettre")
        else:
            self.lettre = self.canvas.create_text(x+20, y+20, text=lettre.upper(),  font=("Helvetica", 30), tags="lettre", fill = "red")

    def placer(self, ref, mot):
        if ref == '': return
		else:
			(i,j,direction) = refcoord(ref)
			if direction == 'v':
				for k in range(len(mot)):
					self.poser(mot[k],(i+k)*40,j*40+80)
			else:
				for k in range(len(mot)):
					self.poser(mot[k],i*40,(j+k)*40+80)

    def suppr(self, ref, mot):
        if ref == '': return
        else:
			self.mot[1] = ''
			self.nonpos = [x for x in self.tir]
			k=0
			for lettre in sorted(self.tir):
				self.poser(lettre, 160+k*40, 0)
				k+=1
			(i,j,direction) = refcoord(ref)
			if direction == 'h':
				for k in range(len(mot)):
					if self.g.est_vide((i,j+k)):
						if (i,j+k) in self.mtco: self.canvas.create_rectangle(i*40,(j+k)*40+80,i*40+40,(j+k)*40+40+80,fill="red")#+80
						elif (i,j+k) in self.mdco: self.canvas.create_rectangle(i*40,(j+k)*40+80,i*40+40,(j+k)*40+40+80,fill="pink")#+80
						elif (i,j+k) in self.ltco: self.canvas.create_rectangle(i*40,(j+k)*40+80,i*40+40,(j+k)*40+40+80,fill="blue")#+80
						elif (i,j+k) in self.ldco: self.canvas.create_rectangle(i*40,(j+k)*40+80,i*40+40,(j+k)*40+40+80,fill="#00bfff")#+80
						else: self.canvas.create_rectangle(i*40,(j+k)*40+80,i*40+40,(j+k)*40+40+80,fill="white")#+80
			else:
				for k in range(len(mot)):
					if self.g.est_vide((i+k,j)):
						if (i+k,j) in self.mtco: self.canvas.create_rectangle((i+k)*40,j*40+80,(i+k)*40+40,j*40+40+80,fill="red")#+80
						elif (i+k,j) in self.mdco: self.canvas.create_rectangle((i+k)*40,j*40+80,(i+k)*40+40,j*40+40+80,fill="pink")#+80
						elif (i+k,j) in self.ltco: self.canvas.create_rectangle((i+k)*40,j*40+80,(i+k)*40+40,j*40+40+80,fill="blue")#+80
						elif (i+k,j) in self.ldco: self.canvas.create_rectangle((i+k)*40,j*40+80, (i+k)*40+40,j*40+40+80,fill="#00bfff")#+80
						else: self.canvas.create_rectangle((i+k)*40,j*40+80,(i+k)*40+40,j*40+40+80,fill="white")#+80
			if self.mot[0]!="":		#retablissement x et y
				(i,j,direction) = refcoord(self.mot[0])
				self.x,self.y = i*40,j*40+80
				if direction == 'h':
					while (self.y<560+80) and self.g.est_occupe(((self.x//40),(self.y//40-2))):
						self.mot[1]+=self.g.get_jeton(((self.x//40),(self.y//40-2)))
						(self.x,self.y) = (self.x, self.y + 40)
				else:
					while (self.x<560) and self.g.est_occupe(((self.x//40),(self.y//40-2))):
						self.mot[1]+=self.g.get_jeton(((self.x//40),(self.y//40-2)))
						(self.x,self.y) = (self.x+40, self.y)

    def __init__(self, fenetre):
        fenetre.title("grille") #modif

        Frame.__init__(self, fenetre)#, width='800 px', height='0 px') #modif comme j'ai pu
        self.pack()

        # création du canvas
        self.canvas = Canvas(fenetre, width=600, height=680, bg="ivory") #+80

        mt=["A1","A8","A15","H1","H15","O1","O8","O15"]
        md=["B2","C3","D4","E5","B14","C13","D12","E11","H8","N2","M3","L4","K5","N14","M13","L12","K11"]
        lt=["B6","B10","F2","F6","F10","F14","J2","J6","J10","J14","N6","N10"]
        ld=["A4","A12","C7","C9","D1","D8","D15","G3","G7","G9","G13","H4","H12","I3","I7","I9","I13","M7","M9","L1","L8","L15","O4","O12"]
        valeurs={"A":1, "B":3, "C":3, "D":2, "E":1, "F":4, "G":2, "H":4, "I":1, "J":8, "K":10, "L":1, "M":2, "N":1, "O":1, "P":3, "Q":8, "R":1, "S":1, "T":1, "U":1, "V":4, "W":10, "X":10, "Y":10, "Z":10}

        for i in range(15): #modif : range
            for j in range(15): #modif : range
                self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="white")#+80

        for case in mt:
            (i,j)=self.CaseToMatrix(case)
            self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="red")#+80

        for case in md:
            (i,j)=self.CaseToMatrix(case)
            self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="pink")#+80

        for case in lt:
            (i,j)=self.CaseToMatrix(case)
            self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="blue")#+80

        for case in ld:
            (i,j)=self.CaseToMatrix(case)
            self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="#00bfff")#+80

        self.mtco = [self.CaseToMatrix(case) for case in mt]
        self.mdco = [self.CaseToMatrix(case) for case in md]
        self.ltco = [self.CaseToMatrix(case) for case in lt]
        self.ldco = [self.CaseToMatrix(case) for case in ld]

		self.textmot = self.canvas.create_text(460, 20, text="Mot :",  font=("Helvetica", 15), tags="texte")
        self.textmax = self.canvas.create_text(460, 60, text="Max :",  font=("Helvetica", 15), tags="texte")
		self.textcumul = self.canvas.create_text(540, 60, text="Cum :",  font=("Helvetica", 15), tags="texte")
		self.textnegatif = self.canvas.create_text(540, 20, text="Nég :",  font=("Helvetica", 15), tags="texte")
		self.textcoups = self.canvas.create_text(40, 60, text="Coup :",  font=("Helvetica", 15), tags="texte")

#        for k in
        # coordonnées initiales
        self.x=0
        self.y=80 #+80
        self.flechestr=["→","↓"]
        # création du rectangle
        #self.rectangle = self.canvas.create_rectangle(0,0,40,40,fill="violet")
        # ajout du bond sur les touches du clavier
        self.canvas.focus_set()
        self.canvas.bind("<Key>", self.clavier)
        self.canvas.bind("<ButtonRelease>", self.souris)

        self.V = { "A": 1, "B" : 3, "C" : 3, "D" : 2, "E" : 1, "F" : 4, "G" : 2, "H" : 4, "I" : 1, "J" : 8, "K" : 10, "L" : 1, "M" : 2, "N" : 1, "O" : 1, "P" : 3, "Q" : 8, "R" : 1, "S" : 1, "T" : 1, "U" : 1, "V" : 4, "W" : 10, "X" : 10, "Y" : 10, "Z" : 10, "?" : 0 }
        self.P = {0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:50,8:75,9:100,10:125}
        self.sac = list("??AAAAAAAAABBCCDDDEEEEEEEEEEEEEEEFFGGHHIIIIIIIIJKLLLLLMMMNNNNNNOOOOOOPPQRRRRRRSSSSSSTTTTTTUUUUUUVVWXYZ")
        self.g = grille_test('/Users/yoannloday/Documents/Scrabble/Python/grille.txt')
        self.tir = []
        self.reliq = []
        self.nonpos = [] #lettres du tirage non posées
        self.started = False  #partie en cours
        self.mot = ['','']
        self.tops = []
        self.coup = 0
        self.sens = 0
        self.maxi = 0
        self.cumul = 0
        self.neg = 0
        self.abandon = False

#		self.minute = 0
#		self.seconde = 0
#		self.canvas.after(10, lambda: self.count()) #à afaire

        # création du canvas
        self.canvas.pack()#side=LEFT, padx=20, pady=80)    #modif

# fonction appellée lorsque l'utilisateur presse une touche
    def clavier(self, event):
        touche = event.keysym
        lettre = event.char
        print(touche)
        try:
#            if self.canvas.find_withtag("curseur")==():
#                self.rectangle = self.canvas.create_rectangle(self.x,self.y,self.x+40,self.y+40, outline="#32cd32", tags="curseur")
#                self.fleche = self.canvas.create_text(self.x+20, self.y+20, text="→", font=("Helvetica", 20, "bold"), tags="curseur")
            if (touche == "Up") and (self.y>0+80): #+80
                (self.x,self.y) = (self.x, self.y - 40)
                self.canvas.move("curseur", 0,-40)
            elif (touche == "Down") and (self.y<560+80): #+80
                (self.x,self.y) = (self.x, self.y + 40)
                self.canvas.move("curseur", 0,40)
            elif (touche == "Right") and (self.x<560):
                (self.x,self.y) = (self.x + 40, self.y)
                self.canvas.move("curseur", 40,0)
            elif (touche == "Left") and (self.x>0):
                (self.x,self.y) = (self.x -40, self.y)
                self.canvas.move("curseur", -40,0)
            elif (touche == "Return"):
                print(self.mot)
                print(self.tops)
                self.canvas.delete("curseur")
                if (self.mot in self.tops) or not(self.started) or self.abandon:
                	self.canvas.delete("score")
                	self.canvas.delete("maximum")
                	self.canvas.delete("cumul")
                	self.canvas.delete("neg")
                	self.abandon = False
					self.suppr(self.mot[0],self.mot[1])
					if self.started:
						self.maxi = 0
						self.maximum = self.canvas.create_text(490, 60, text=self.S.trouves[0][2],  font=("Helvetica", 15), tags="maximum")
						self.cumul += self.S.trouves[0][2]
						self.cumultxt = self.canvas.create_text(580, 60, text=self.cumul,  font=("Helvetica", 15), tags="cumul")
						self.negtxt = self.canvas.create_text(580, 20, text=self.neg,  font=("Helvetica", 15), tags="neg")
						top = rd.choice(self.tops)
						self.placer(top[0],top[1])
						self.reliq = self.S.reliquat(top[0],top[1])
						self.g.placer_mot(top[0],top[1])
					else: self.started = True
                    self.total = self.sac + self.reliq
                    self.mot = ['','']
                    if len(self.total)>1 and (('Y' in self.total) or ('?' in self.total) or (voy(self.total)>0 and cons(self.total)>0)):
						self.coup +=1
						self.canvas.delete("coup")
						self.couptxt = self.canvas.create_text(80, 60, text=self.coup,  font=("Helvetica", 20), tags="coup")
                        self.tir ,self.sac = tirage(self.sac, self.reliq, self.coup, 7)
                        self.nonpos = [x for x in self.tir]
                        self.tir,self.nonpos = sorted(self.tir),sorted(self.nonpos)
                        self.S = Solveur(Gc,self.g,fusion(self.tir),V,P,7)
                        self.S.cherche()
                        self.S.tri_solutions()
                        k=0
                        self.tops = []
                        if self.S.trouves == []: return
                        while k<len(self.S.trouves) and self.S.trouves[k][2]==self.S.trouves[0][2]:
                            self.tops.append([self.S.trouves[k][0],self.S.trouves[k][1]])
                            k+=1
                        k=0
                        for lettre in self.tir:
                            self.poser(lettre, 160+k*40, 0)
                            k+=1
						for m in range(k,7):
							self.canvas.create_rectangle(160+m*40,0,160+m*40+40,40,fill="white")
						self.maximum.pack()
					else:
						self.started = False
						k=0
						for lettre in self.reliq:
							self.poser(lettre, 160+k*40, 0)
							k+=1
						for m in range(k,7):
							self.canvas.create_rectangle(160+m*40,0,160+m*40+40,40,fill="white")
						self.fin = self.canvas.create_text(300, 60, text="FIN",  font=("Helvetica", 40), tags="fin")
						self.fin.pack()

				else:
					self.canvas.delete("curseur")
					self.canvas.delete("score")
					for sol in self.S.trouves:
						if sol[0]==self.mot[0] and sol[1]==self.mot[1]:
							self.suppr(self.mot[0],self.mot[1])
							self.score = self.canvas.create_text(490, 20, text=sol[2],  font=("Helvetica", 15), tags="score")
							if sol[2]>=self.maxi:
								self.maxi = sol[2]
								self.canvas.delete("maximum")
								self.maximum = self.canvas.create_text(490, 60, text=sol[2],  font=("Helvetica", 15), tags="maximum")
								self.maximum.pack()
							self.score.pack()
							break
					self.score = self.canvas.create_text(490, 20, text=0,  font=("Helvetica", 15), tags="score")
					if self.maxi == 0:
						self.canvas.delete("maximum")
						self.maximum = self.canvas.create_text(490, 60, text=0,  font=("Helvetica", 15), tags="maximum")
					self.suppr(self.mot[0],self.mot[1])

            elif (touche == "space"):
                self.sens=(self.sens+1)%2
                self.canvas.itemconfigure(self.fleche, text=self.flechestr[self.sens])
                self.mot = ['','']
                if self.sens==0: mot[0]=coordref((self.x//40,self.y//40-2),'h')#
                else: mot[0]=coordref((self.x//40,self.y//40-2),'v')#

            elif (touche in "abcdefghijklmnopqrstuvwxyz"): #
                jouer = False
                for k in range(len(self.nonpos)):
                    if self.nonpos[k]==touche.upper():
                        self.poser(touche.upper(), self.x, self.y) #
                        self.mot[1]+=touche.upper()
                        self.nonpos[k]=''
                        self.canvas.create_rectangle(160+k*40,0,160+k*40+40,40,fill="white")
                        jouer = True
                        break
                if jouer and self.sens and (self.y<560+80): #+80 (suppr y<)
                    while (self.y<560+80) and self.g.est_occupe(((self.x//40),(self.y//40-2+1))):
                        self.mot[1]+=self.g.get_jeton(((self.x//40),(self.y//40-2+1)))
                        (self.x,self.y) = (self.x, self.y + 40)
                        self.canvas.move("curseur", 0,40)
                    if (self.y<560+80):
                        (self.x,self.y) = (self.x, self.y + 40)
                        self.canvas.move("curseur", 0,40)
                    else:
                        self.canvas.delete("curseur")
                elif jouer and self.sens+1==1 and (self.x<560): #suppr x<560
                    while (self.x<560) and self.g.est_occupe(((self.x//40+1),(self.y//40-2))):
                        self.mot[1]+=self.g.get_jeton(((self.x//40+1),(self.y//40-2)))
                        (self.x,self.y) = (self.x+40, self.y)
                        self.canvas.move("curseur", 40,0)
                    if (self.x<560):
                        (self.x,self.y) = (self.x+40, self.y)
                        self.canvas.move("curseur", 40,0)
                    else:
                        self.canvas.delete("curseur")

            elif (touche in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
                jouer = False
                for k in range(len(self.nonpos)):
                    if self.nonpos[k]=='?':
                        self.poser(touche.lower(), self.x, self.y) #
                        self.mot[1]+=touche.lower()
                        self.nonpos[k]=''
                        self.canvas.create_rectangle(160+k*40,0,160+k*40+40,40,fill="white")
                        jouer = True
                        break
                if jouer and self.sens and (self.y<560+80): #+80 (suppr y<)
                    while (self.y<560+80) and self.g.est_occupe(((self.x//40),(self.y//40-2+1))):
                        self.mot[1]+=self.g.get_jeton(((self.x//40),(self.y//40-2+1)))
                        (self.x,self.y) = (self.x, self.y + 40)
                        self.canvas.move("curseur", 0,40)
                    if (self.y<560+80):
                        (self.x,self.y) = (self.x, self.y + 40)
                        self.canvas.move("curseur", 0,40)
                    else:
                        self.canvas.delete("curseur")
                elif jouer and self.sens+1 and (self.x<560): #suppr x<560
                    while (self.x<560) and self.g.est_occupe(((self.x//40+1),(self.y//40-2))):
                        self.mot[1]+=self.g.get_jeton(((self.x//40+1),(self.y//40-2)))
                        (self.x,self.y) = (self.x+40, self.y)
                        self.canvas.move("curseur", 40,0)
                    if (self.x<560):
                        (self.x,self.y) = (self.x+40, self.y)
                        self.canvas.move("curseur", 40,0)
                    else:
                        self.canvas.delete("curseur")
			elif (touche == "at"): #reset grille
				self.sac = list("??AAAAAAAAABBCCDDDEEEEEEEEEEEEEEEFFGGHHIIIIIIIIJKLLLLLMMMNNNNNNOOOOOOPPQRRRRRRSSSSSSTTTTTTUUUUUUVVWXYZ")
				self.g = grille_test('/Users/yoannloday/Documents/Scrabble/Python/grille.txt')
				self.canvas.delete("fin")
				self.tir = []
				self.reliq = []
				self.nonpos = []
				self.started = False
				self.mot = ['','']
				self.tops = []
				self.coup = 0
				self.sens = 0
				self.maxi = 0
				self.cumul = 0
				self.neg = 0
				for i in range(15):
					for j in range(15): self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="white")#+80
				for (i,j) in self.mtco: self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="red")#+80
				for (i,j) in self.mdco: self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="pink")#+80
				for (i,j) in self.ltco: self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="blue")#+80
				for (i,j) in self.ldco: self.canvas.create_rectangle(i*40,j*40+80,i*40+40,j*40+40+80,fill="#00bfff")#+80
				for m in range(7): self.canvas.create_rectangle(160+m*40,0,160+m*40+40,40,fill="white")
			elif (touche == "minus"): #negatif (c'est pas très bien fait)
				self.neg += self.maxi - self.S.trouves[0][2]
				self.abandon = True

#			elif (touche == "BackSpace"):
#				return

        except AttributeError:
            self.rectangle = self.canvas.create_rectangle(self.x,self.y,self.x+40,self.y+40, outline="#32cd32", tags="curseur")
            self.fleche = self.canvas.create_text(self.x+20, self.y+20, text=self.flechestr[self.sens], font=("Helvetica", 20, "bold"), tags="curseur")

    # changement de coordonnées pour le rectangle
#        self.canvas.coords(self.rectangle, self.x, self.y, self.x+40, self.y+40)

    def souris(self, event):
        num = event.num
        newx = int(event.x/40)*40 #//
        newy = int(event.y/40)*40
        self.suppr(self.mot[0],self.mot[1])
        try:
            if self.canvas.find_withtag("curseur")==():
                self.x = newx
                self.y = newy
                self.sens = num//2
                self.rectangle = self.canvas.create_rectangle(self.x,self.y,self.x+40,self.y+40, outline="#32cd32", width=3, tags="curseur")
                self.fleche = self.canvas.create_text(self.x+20, self.y+20, text=self.flechestr[self.sens], font=("Helvetica", 20, "bold"), tags="curseur")

#                if self.sens==0: self.mot[0]=coordref((self.x//40,self.y//40-2),'v')#
#                else: self.mot[0]=coordref((self.x//40,self.y//40-2),'h')#

                if self.sens==0:
					if not('v' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['v']
					self.mot[0] = coordref((self.x//40 - len(self.mot[1]) ,self.y//40-2),'v')#
                else:
					if not('h' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['h']
					self.mot[0] = coordref((self.x//40 ,self.y//40-2 - len(self.mot[1])),'h')#

            elif newx==self.x and newy==self.y and self.sens==num//2:
                self.sens=(1+self.sens)%2
                self.canvas.itemconfigure(self.fleche, text=self.flechestr[self.sens])
                if self.sens==0:
					if not('v' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['v']
					self.mot[0] = coordref((self.x//40 - len(self.mot[1]) ,self.y//40-2),'v')#
                else:
					if not('h' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['h']
					self.mot[0] = coordref((self.x//40 ,self.y//40-2 - len(self.mot[1])),'h')#
            elif newx==self.x and newy==self.y and self.sens!=num//2:
                self.sens=num//2
                self.canvas.itemconfigure(self.fleche, text=self.flechestr[self.sens])
                if self.sens==0:
					if not('v' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['v']
					self.mot[0] = coordref((self.x//40 - len(self.mot[1]) ,self.y//40-2),'v')#
                else:
					if not('h' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['h']
					self.mot[0] = coordref((self.x//40 ,self.y//40-2 - len(self.mot[1])),'h')#
            else:
                self.sens=num//2
                self.canvas.move("curseur", newx-self.x, newy-self.y) #switched
                self.canvas.itemconfigure(self.fleche, text=self.flechestr[self.sens]) #switched
                self.x = newx
                self.y = newy
                if self.sens==0:
					if not('v' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['v']
					self.mot[0] = coordref((self.x//40 - len(self.mot[1]) ,self.y//40-2),'v')#
                else:
					if not('h' in self.S.pref[self.x//40][self.y//40-2]): self.mot[1] = ''
					else: self.mot[1] = self.S.pref[self.x//40][self.y//40-2]['h']
					self.mot[0] = coordref((self.x//40 ,self.y//40-2 - len(self.mot[1])),'h')#
        except AttributeError:
            print("EXCEPT")
            self.rectangle = self.canvas.create_rectangle(self.x,self.y,self.x+40,self.y+40, outline="#32cd32", width=3, tags="curseur")
            self.fleche = self.canvas.create_text(self.x+20, self.y+20, text="→", tags="curseur", font=("Helvetica", 20, "bold"))

    def countdown(t):
        while t: #modif : indentation
            mins, secs = divmod(t, 60)
            timeformat = '{:02d}:{:02d}'.format(mins, secs)
            print(timeformat, end='\r')
            time.sleep(1)
            t -= 1

	def count(self):
		print('coucou')
        if self.started:
            if int(seconde) < 59:
                self.seconde = int(self.seconde)
                self.seconde += 1
            else:
                self.seconde = '00'
                self.minute = int(minute)
                self.minute += 1
            self.seconde = str(self.seconde)
            self.seconde = str(self.seconde)
            if len(self.seconde) == 1:
                self.seconde = '0' + self.seconde
            time = self.minute + ' : ' + self.seconde

            self.chrono = Label(self.frame, text=time, font=("Helvetica", 20))
			self.chrono.grid(row=0, column=2)


#            self.canvas.delete("chrono")
 #           self.chrono = self.canvas.create_text(20,20, text=time, font=("Helvetica", 20), tags="chrono")
	#		self.chrono.pack()


fenetre = Tk()
interface = Interface(fenetre)

interface.mainloop()

import time
import random as rd #modif

class GaddagNode:
	"""Classe de noeuds constituant le gaddag"""
	def __init__(self, id):
		self.id = id
		self.possibles = ""
		self.edges = {}

	def __str__(self):
		str_list = [self.possibles]
		for (label, node) in self.edges.items():
			str_list.append(label)
			str_list.append(str(node.id))
		return '_'.join(str_list)

	def __hash__(self):
		return self.__str__().__hash__()

	def __eq__(self, autre):
		return self.__str__() == autre.__str__()

	def copy(self):
		new_node = GaddagNode(self.id)
		new_node.possibles = self.possibles
		new_node.edges = self.edges
		return new_node

class Gaddag:
	"""Classe du gaddag (cf article pour son principe)"""
	compteurNodes = 0
	def __init__(self):
		self.root = GaddagNode(Gaddag.compteurNodes)
		self.mot_precedent = ""
		self.a_verifier = []
		self.Node_minimises = {}
		self.Node_list = []
		Gaddag.compteurNodes += 1

	def inserer(self, mot):
		"""routine d'insertion des mots dans le gaddag (cf. article)"""
		if mot <= self.mot_precedent:
			raise Exception("Erreur: les mots doivent être insérés dans l'ordre alphabétique")
		prefixe_commun = 0
		for i in range(min(len(mot), len(self.mot_precedent))):
			if mot[i] != self.mot_precedent[i]:
				break
			prefixe_commun += 1
		
		if len(self.mot_precedent) == prefixe_commun and self.mot_precedent != "":
			prefixe_commun -= 1

		self.minimize(prefixe_commun)

		if len(self.a_verifier) == 0:
			node = self.root
		else:
			node = self.a_verifier[-1][2]

		for lettre in mot[prefixe_commun:len(mot)-1]:
			node_suivant = GaddagNode(Gaddag.compteurNodes)
			Gaddag.compteurNodes += 1
			node.edges[lettre] = node_suivant
			self.a_verifier.append((node, lettre, node_suivant))
			node = node_suivant

		node.possibles =''.join(sorted(node.possibles+mot[-1]))
		self.mot_precedent = mot

	def termine(self):
		"""routine terminant la simplification du gaddag quand le dernier mot est ajouté"""
		self.minimize(0)
		self.Node_minimises[self.root] = self.root
		self.renumber()

	def renumber(self):
		"""routine de redéfinition des labels des noeuds"""
		node_list = []
		id_map = {}
		def ajoute_node_list(node):
			if str(node.id) in id_map.keys():
				return
			node_list.append(node)
			id_map[str(node.id)] = len(id_map)
			for label, fils in node.edges.items():
				ajoute_node_list(fils)
		ajoute_node_list(self.root)
		for i in range(len(node_list)):
			node = node_list[i].copy()
			for label, fils in node.edges.items():
				node.edges[label] = id_map[str(fils.id)]
			node_list[i] = node
		for i in range(len(node_list)):
			node_list[i].id = id_map[str(node_list[i].id)]
		self.Node_list = node_list

	def minimize(self, ind_reduc):
		"""routine de minimisation du gaddag par recherche de noeuds identiques"""
		for i in range(len(self.a_verifier)-1, ind_reduc-1, -1):
			(parent, lettre, fils) = self.a_verifier[i]
			if fils in self.Node_minimises:
				parent.edges[lettre] = self.Node_minimises[fils]
			else:
				self.Node_minimises[fils] = fils
			self.a_verifier.pop()

	def parcours(self, node, pile):
		"""routine de parcours de l'arbre à partir d'un noeud donné et d'un chemin à suivre (donné sous forme de pile)"""
		while pile:
			lettre = pile.pop()
			if (node is None or not(lettre in node.edges)): return None #jsp comment fonctionne try mais ça marche pas -> modifié
            else : node = self.Node_list[node.edges[lettre]] # modif pour renvoyer noeud et pas int
		return node
		
	def parcours_list(self, index, pile):
		"""routine de parcours de l'arbre quand il est sous forme de liste (à tester)"""
		while pile:
			lettre = pile.pop()
			try:
				index = self.Node_list[index][lettre]
			except KeyError:
				return None
		return self.Node_list[index]

	def cherche(self, mot):
		"""routine de recherche d'un mot dans l'arbre"""
		node = self.root
		pile = list(mot)
		lettre1 = pile.pop(0)
		node = self.parcours(node, pile)
		return lettre1 in node.possibles
	
	def cherche_list(self, mot):
		"""routine de recherche d'un mot dans l'arbre quand il a été mis sous forme de liste (à tester)"""
		pile = list(mot)
		lettre1 = pile.pop(0)
		node = self.parcours_list(0, pile)
		return lettre1 in node.possibles

	def anagram_list(self, tirage):
		"""routine de recherche d'anagramme (à faire)"""
		pass
		

	def pivot(self, pref2, suff2): #modif
		"""routine de recherche des pivots"""
		pref, suff = pref2.upper(),suff2.upper() #modif
		node = self.root
		if len(suff) >= len(pref):
			pile = list(suff)	
			node = self.parcours(node, pile)
			if node is None:
				return ""
			if pref == "":
				return node.possibles
			else:
				possibles = ""
				for char in node.edges.keys():
					node_test = self.parcours(node, list(pref[1:]+char))
					if node_test is not None and pref[0] in node_test.possibles:
						possibles += char
				return possibles
		else:
			pile = list(reversed(pref))
			pile.insert(-1, "!")
			node = self.parcours(node, pile)
			if node is None:
				return ""
			if suff == "":
				return node.possibles
			else:
				possibles = ""
				for char in node.edges.keys():
					node_test = self.parcours(node, list(reversed(char+suff[:-1])))
					if node_test is not None and suff[-1] in node_test.possibles:
						possibles += char
				return possibles


	def pivot2(self, pref, suff): # à modifier (lowercase)
		"""routine de recherche des pivots, simple mais pas opti"""
		pivot_possible = ""
		for char in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
			if self.cherche(pref+char+suff):
				pivot_possible += char
		return pivot_possible


	def nb_nodes(self):
		"""routine donnant le nombre de noeuds de l'arbre"""
		return len(self.Node_minimises)

	def nb_aretes(self):
		"""routine donnant le nombre d'arètes de l'arbre"""
		compte = 0
		for node in self.Node_minimises:
			compte += len(node.edges)
		return compte

	def exporter(self, filename):
		"""routine d'export de l'arbre : on le met sous forme de liste de noeuds qu'on exporte dans un fichier txt"""
		with open(filename, 'w') as file:
			for node in self.Node_list:
				nodestr = str(node.id) + ',' + node.possibles + ','
				for (label, node_fils) in node.edges.items():
					nodestr += label + str(node_fils) + ','
				file.write(nodestr[:-1] + '\n')
		return('Fichier créé')

	def display(self):
		"""routine d'affichage de l'arbre; Éviter d'utiliser sur un arbre gros..."""
		pile = [self.root]
		finis = set()
		while pile:
			node = pile.pop()
			if node.id in finis:
				continue
			finis.add(node.id)
			print("{}: {}".format(node.id, node))
			if len(node.possibles)>0:
				print('    ('+node.possibles+')')
			for label, fils in node.edges.items():
				print("    {} vers {}".format(label, fils.id))
				pile.append(fils)

def importer(self, filename):
	"""routine d'import d'un fichier de noeuds et de construction du gaddag résultant mis sous forme de liste"""
	dico = Gaddag()
	with open(filename) as file:
		for line in file:
			node_list = line.strip().split(',')
			new_node = GaddagNode(int(node_list.pop(0)))
			new_node.possibles = node_list.pop(0)
			new_node.edges = dict()
			if node_list:
				for elt in node_list:
					new_node.edges[elt[0]] = int(elt[1:])
			dico.Node_list.append(new_node)
	print('Fichier importé')
	return dico

def build_dic():
	"""routine de contruction du gaddag à partir d'un fichier txt de mots"""
	start = time.time()
	gaddag = Gaddag()
	mots = []
	with open('/Users/yoannloday/Documents/Scrabble/ods8.txt') as file:
		for ligne in file:
			mot = ligne.strip()
			mots.append(mot[::-1])
			for i in range(len(mot)-1):
				mots.append(mot[i::-1]+'!'+mot[i+1:])
		print("Liste terminée en {0}s".format(time.time()-start))
		for mot in sorted(mots):
			gaddag.inserer(mot)
		print("Mots insérés en {0}s".format(time.time()-start))
		gaddag.termine()
		print("Création du gaddag en {0}s".format(time.time()-start))
	return gaddag

def refcoord(ref):
    if len(ref)==2:
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            return ord(ref[0])-ord('A') , int(ref[1])-1, 'h'
        else:
            return ord(ref[1])-ord('A') , int(ref[0])-1, 'v'
    else:
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            return  ord(ref[0])-ord('A') , int(ref[1:])-1, 'h'
        else:
            return ord(ref[2])-ord('A') , int(ref[:2])-1, 'v'
    

##

class Grille:
	"""Classe construisant la grille de jeu"""
	def __init__(self, taille, bonus):
		self.taille = taille
		self.jetons = []
		self.bonus = bonus
# j'ai trafiqué get_multiplicateur qui marchait pas, modif
    #self.mult_mot = get_multiplicateur('M')
		gm = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if 'M' in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			gm.append(l)
        self.mult_mot = gm
    #self.mult_lettre = get_multiplicateur('L')
		gl = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if 'L' in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			gl.append(l)
        self.mult_lettre = gl
		for i in range(taille):
			ligne = []
			for j in range(taille):
				ligne.append(None)
			self.jetons.append(ligne)

	def __str__(self):
		return '\n'.join(''.join(x if x is not None else '_' for x in ligne) for ligne in self.jetons)

    def __print__(self): #ajout (on critique pas la qualité)
        for i in range(15):
            s = ""
            for j in range(15):
                if self.est_occupe((i,j)): s+=self.get_jeton((i,j))
                else : s+= " "
            print(s)

	def coord_cases(self):
		liste_coord = []
		for ligne in range(self.taille):
			for col in range(self.taille):
				liste_coord.append((ligne, col))
		return liste_coord

	def get_jeton(self, pos):
		ligne, col = pos
		return self.jetons[ligne][col]

	def set_jeton(self, pos, jeton):
		ligne, col = pos
		self.jetons[ligne][col] = jeton
		
    def placer_mot(self, ref, mot): #modif
        ligne, col = refcoord(ref)[:2]
        if 0 <= ord(ref[0]) - ord('A') <= 25:
            for k in range(len(mot)):
                self.set_jeton((ligne , col + k), mot[k])
        else:
            for k in range(len(mot)):
                self.set_jeton((ligne + k, col), mot[k])
	
	def check_limites(self, pos):
		ligne, col = pos
		return ligne >= 0 and ligne < self.taille and col >= 0 and col < self.taille

	def est_vide(self, pos):
		return self.check_limites(pos) and self.get_jeton(pos) is None

	def est_occupe(self, pos):
		return self.check_limites(pos) and self.get_jeton(pos) is not None

	def copy(self):
		resultat = Grille(self.taille, self.bonus)
		for pos in self.coord_cases():
			resultat.set_jeton(pos, self.get_jeton(pos))
		return resultat

	def get_multiplicateur(self, char): #sert plus à rien
		g = []
		for ligne in self.bonus:
			l = []
			for case in ligne:
				if char in case:
					l.append(int(case[1:]))
				else:
					l.append(1)
			g.append(l)
		return g

def grille_test(src):
	"""routine de construction de la grille à partir d'un fichier de paramètres comme celui fourni"""
	bonus = []
	with open(src, 'r') as g_txt:
			taille = int(g_txt.readline().strip())
			for line in g_txt:
				ligne = line.strip().split(',')
				if len(ligne) != taille:
					return('Erreur dans le fichier de paramètres de la grille')
				else:
					bonus.append(ligne)
	return(Grille(taille, bonus))

# g = grille_test('/Users/yoannloday/Documents/Scrabble/Python/grille.txt')

V = { "A": 1, "B" : 3, "C" : 3, "D" : 2, "E" : 1, "F" : 4, "G" : 2, "H" : 4, "I" : 1, "J" : 8, "K" : 10, "L" : 1, "M" : 2, "N" : 1, "O" : 1, "P" : 3, "Q" : 8, "R" : 1, "S" : 1, "T" : 1, "U" : 1, "V" : 4, "W" : 10, "X" : 10, "Y" : 10, "Z" : 10, "?" : 0 }

P = {0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:50,8:75,9:100,10:125}

##
#from dico_gaddag import build_dic
#from grille import grille_test

#import time

class Solveur:
	"""Classe qui calcule le meilleur coup sur une grille donnée selon un tirage et un dico donnés"""
	def __init__(self, dico, grille, chevalet, valeurs, primes, nb_lettres_autorisees): #modif
		self.dico = dico
		self.grille = grille
		self.chevalet = chevalet
		self.valeurs = valeurs
		self.primes = primes
		self.nb_lettres_interdites = max(0 , len(chevalet) - nb_lettres_autorisees) #modif
		self.pivot = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.pref = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.suff = [[dict() for _ in range(grille.taille)] for _ in range(grille.taille)]
		self.score_pivot = [[{'v':0,'h':0} for _ in range(grille.taille)] for _ in range(grille.taille)] #modif pour résoudre KeyError
		self.ancres = []
		self.trouves = []
                
	def avant(self, pos, direction):
		"""retourne la case avant pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col-1
		else:
			return ligne-1, col

	def apres(self, pos, direction):
		"""retourne la case après pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col+1
		else:
			return ligne+1, col

	def shift(self, pos, shift, direction):
		"""retourne la case shiftée de shift cases par rapport à pos dans une direction donnée"""
		ligne, col = pos
		if direction == 'h':
			return ligne, col+shift
		else:
			return ligne+shift, col

	def trouve_ancres(self):
		"""retourne les ancres (cases adjacentes à des jetons déjà sur la grille ou case centrale si grille vide)"""
		ancres = []
		for pos in self.grille.coord_cases():
			vide = self.grille.est_vide(pos)
			voisins_occupes = self.grille.est_occupe(self.avant(pos,'h')) or self.grille.est_occupe(self.apres(pos,'h')) or self.grille.est_occupe(self.avant(pos,'v')) or self.grille.est_occupe(self.apres(pos,'v')) 
			if vide and voisins_occupes:
				ancres.append(pos)
		if not ancres:
			ancres.append((7,7)) #à adapter plus tard
		self.ancres = ancres

	def update_pivot(self):
		"""Calcule les pivots suivant la grille donnée"""
		for pos in self.ancres:
			for direction in ['h', 'v']:
				pref, suff = "", ""
				pos_test = self.avant(pos, direction)
				while self.grille.est_occupe(pos_test):
					pref = self.grille.get_jeton(pos_test) + pref
					pos_test = self.avant(pos_test, direction)

				pos_test = self.apres(pos, direction)
				while self.grille.est_occupe(pos_test):
					suff = suff + self.grille.get_jeton(pos_test)
					pos_test = self.apres(pos_test, direction)

				ligne, col = pos
				if pref or suff:
					self.pivot[ligne][col][direction] = self.dico.pivot(pref, suff)
					self.pref[ligne][col][direction] = pref
					self.suff[ligne][col][direction] = suff
					self.score_pivot[ligne][col][direction] = self.compte_pivot(ligne, col, direction, pref+suff)

	def compte_pivot(self, ligne, col, direction, seq):
		"""Compte les mots en pivot"""
		compte = 0
		for lettre in seq:
			try:
				compte += self.valeurs[lettre]
			except KeyError:
				pass
		return compte

	def get_valeur(self, lettre):
		"""Retourne la valeur d'une lettre"""
		try:
			return self.valeurs[lettre]
		except KeyError:
			return 0

	def cherche(self):
	    print(self.chevalet)
		"""Cherche tous les coups possibles en parcourant toutes les ancres"""
		start = time.time()
		self.trouve_ancres()
		self.update_pivot()
		for ancre in self.ancres:
			for direction in ['h','v']:
				try:
					suff = self.suff[ancre[0]][ancre[1]][direction]
					node = self.dico.parcours(self.dico.root, list(suff.upper()))
				except KeyError:
					suff = ''
					node = self.dico.root
				chevalet = [x for x in self.chevalet]
				self.generer_coups(ancre, 0, direction, suff, chevalet, node)
		print("Recherche faite en {0}s".format(time.time()-start))

	def autorises(self, pos, direction):
		"""Retourne toutes les lettres autorisées sur une case pos"""
		ligne, col = pos
		if not(0 <= ligne < 15 and 0 <= col < 15): return "" #modif (try marche pas ?)
		else: # modif
            try:
                return self.pivot[ligne][col][direction]
            except KeyError:
                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	def generer_coups(self, pos_ancre, shift, direction, mot, chevalet, node):
#	    print(shift,mot)
		"""Pour une ancre donnée, essaye toutes les lettres possibles selon le dico (première routine de l'article)"""
		pos_scan = self.shift(pos_ancre, shift, direction)
		if direction == 'h':
			direction_perp = 'v'
		else:
			direction_perp = 'h'
		if self.grille.est_occupe(pos_scan):
			lettre = self.grille.get_jeton(pos_scan)
#			self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
            if lettre == lettre.upper(): self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
            else: self.aller_a(pos_ancre, shift, direction, lettre.upper(), mot, chevalet, node, True)
		elif len(chevalet) > self.nb_lettres_interdites: #modif
			for lettre in set(chevalet.copy()):
				if lettre in self.autorises(pos_scan, direction_perp):
					chevalet.remove(lettre)
					self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, False)
					chevalet.append(lettre)
			if '?' in chevalet:
				for lettre in self.autorises(pos_scan, direction_perp):
					chevalet.remove('?')
					self.aller_a(pos_ancre, shift, direction, lettre, mot, chevalet, node, True)
					chevalet.append('?')

	def aller_a(self, pos_ancre, shift, direction, lettre, mot, chevalet, node, est_jok):
		"""Une fois la lettre posée, teste toutes les cases sur lesquelles on peut continuer la recherche (deuxième routine de l'article)"""
		pos_scan = self.shift(pos_ancre, shift, direction)
		if shift <= 0:
			mot = lettre + mot
			if est_jok:
				mot = mot[:1].lower() + mot[1:]
			if node is not None and lettre in node.possibles and not self.grille.est_occupe(self.avant(pos_scan, direction)):
				self.enregistre(pos_scan, direction, mot)
			node = self.dico.parcours(node, [lettre])
			if node is not None:
				pos_scan = self.avant(pos_scan, direction)
				if pos_scan not in self.ancres: #and self.grille.check_limites(pos_scan): # pas modif
					self.generer_coups(pos_ancre, shift-1, direction, mot, chevalet, node)
				node = self.dico.parcours(node, ['!'])
				try:
					shift_apres = len(self.suff[pos_ancre[0]][pos_ancre[1]][direction]) + 1
				except KeyError:
					shift_apres = 1
				if node is not None and not self.grille.est_occupe(pos_scan): # and self.grille.check_limites(pos_scan): # pas modif 
					self.generer_coups(pos_ancre, shift_apres, direction, mot, chevalet, node)
		else:
			mot = mot + lettre
			if est_jok:
				mot = mot[:-1] + mot[-1].lower()
			if node is not None and lettre in node.possibles and not self.grille.est_occupe(self.apres(pos_scan, direction)):
				self.enregistre(self.shift(pos_scan, -len(mot)+1, direction), direction, mot)
			node = self.dico.parcours(node, [lettre])
			if node is not None: #and self.grille.est_vide(self.apres(pos_scan, direction)): #modif
				self.generer_coups(pos_ancre, shift+1, direction, mot, chevalet, node)
# aucune vérification de sortie de grille ?
# pb avec les double appuis

    def compte(self, pos, direction, mot):
        """Compte le mot trouvé"""
        c = 0
        nb_lettres_posees = 0
        mult_mot = 1
        pos_scan = pos
        compte_pivot = 0
        if direction == 'h':
            direction_perp = 'v'
        else:
            direction_perp = 'h'
        for lettre in mot:
            valeur_lettre = self.get_valeur(lettre)
            if self.grille.est_occupe(pos_scan):
                c += valeur_lettre
            else:
                nb_lettres_posees += 1
                mult_lettre = self.grille.mult_lettre[pos_scan[0]][pos_scan[1]]
                mult_mot_pivot = self.grille.mult_mot[pos_scan[0]][pos_scan[1]]
                mult_mot *= mult_mot_pivot
                c += valeur_lettre*mult_lettre
                try:
                    compte_pivot_case = self.score_pivot[pos_scan[0]][pos_scan[1]][direction_perp] #à tester pour voir si ça marche avec le None (spoiler ça marche pas)
                except KeyError:
                    compte_pivot_case = 0
                if compte_pivot_case > 0 or (direction_perp in self.pref[pos_scan[0]][pos_scan[1]]) or (direction_perp in self.suff[pos_scan[0]][pos_scan[1]]): #modif (cas ou pivot sur joker)
                    compte_pivot_case += valeur_lettre*mult_lettre
                compte_pivot += mult_mot_pivot*compte_pivot_case
            pos_scan = self.apres(pos_scan, direction)
        return(mult_mot*c + compte_pivot + self.primes[nb_lettres_posees])

	def enregistre(self, pos, direction, mot):
		"""Enregistre un mot trouvé"""
		ref = chr(ord('A')+pos[0])
		if direction == 'h':
			ref += str(pos[1]+1)
		else:
			ref = str(pos[1]+1) + ref
		score = self.compte(pos, direction, mot)
		self.trouves.append((ref, mot, score))

	def tri_solutions(self): #à voir si cette fonction a sa place ici (peut-être dans un futur partie.py ?)
		self.trouves.sort(key = lambda a: (-a[2], a[1]))
		
    def reliquat(self, ref, mot):
        reliq = list(self.chevalet)
        c,l,direction = refcoord(ref)
        pos_scan = c,l
        for lettre in mot:
            if not(self.grille.est_occupe(pos_scan)):
                if lettre == lettre.upper():
                    for k in range(len(reliq)):
                        if reliq[k] == lettre:
                            reliq.pop(k)
                            break
                else:
                    for k in range(len(reliq)):
                        if reliq[k] == '?':
                            reliq.pop(k)
                            break
            pos_scan = self.apres(pos_scan, direction)
        return reliq
            
        
        




# débuggage et additions
# get multiplicateur définie en dehors (redéfinie dans init)
# parcours qui renvoie un integer et pas un node (modifié le return de parcours)
# compte_pivot_case plante quand direction est pas dans le dictionnaire -> initialisation de score_pivot à {'v':0,'h':0}
# rajouté les 7/8 -> quand il reste que 6 lettres
# pivot sur mot avec joker -> pref et suff en majuscule + suff en maj dans cherche

# refcoord grille.print placer_mot reliquat

def voy(s):
    m = 0 
    for k in s:
        if k in "AEUIO":
            m+=1
    return m

def cons(s):
    m = 0 
    for k in s:
        if not(k in "AEUIOY?"):
            m+=1
    return m

def tirage(sac2, reliquat, coup, nb_lettres): #verifier sac>1, voy+y+jok>=1, cons+y+jok>=1
    sac = sac2.copy()
    tirage = reliquat.copy()
    if coup <= 15:
        v,c = min(2,voy(sac+tirage)),min(2,cons(sac+tirage))
        if v>0 and c>0:
            while voy(tirage)<v or cons(tirage)<c or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
        else:
            while not('Y' in tirage or '?' in tirage) or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
    else:
        v,c = min(1,voy(sac+tirage)),min(1,cons(sac+tirage))
        if v>0 and c>0:
            while voy(tirage)<v or cons(tirage)<c or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
        else:
            while not('Y' in tirage or '?' in tirage) or (len(tirage)<nb_lettres and len(sac)>0):
                if len(tirage) ==  nb_lettres:
                    sac = sorted(sac + tirage)
                    tirage = []
                for k in range(min(nb_lettres,len(sac)+len(tirage)) - len(tirage)):
                    tirage += sac.pop(rd.randint(0,len(sac)-1))
    return tirage , sac

def fusion(l):
    s = ""
    for k in l: s+=k
    return s

def Partie(dico, grille, sac2, nb_lettres, valeurs, primes, nb_lettres_autorisees): 
    sac = list(sac2)
    l = []
    reliq = []
    total = sac + reliq
    while len(total)>1 and (('Y' in total) or ('?' in total) or (voy(total)>0 and cons(total)>0)):
        t,sac = tirage(sac, reliq, len(l)+1, nb_lettres)
        S = Solveur(dico,grille,fusion(t),valeurs,primes,nb_lettres_autorisees)
        S.cherche()
        S.tri_solutions()
        while S.trouves == []:
            sac,reliq = sorted(sac+t),[]
            t,sac = tirage(sac, reliq, len(l)+1, nb_lettres)
            S = Solveur(dico,grille,fusion(t),valeurs,primes,nb_lettres_autorisees)
            S.cherche()
            S.tri_solutions()
        k=0
        tops = []
        while k<len(S.trouves) and S.trouves[k][2]==S.trouves[0][2]:
            tops.append(S.trouves[k])
            k+=1
        top = rd.choice(tops)
        reliq = S.reliquat(top[0],top[1])
        l.append((fusion(t),top[0],top[1],top[2]))
        grille.placer_mot(top[0],top[1])
        total = sac + reliq
    return l
    
## Crabb

for no in Gc.Node_list:
    for l in no.edges.items():
        if not(l[0] in no.possibles) and l[0]!= '!':
            no.possibles += l[0]

##
R=list("??AAAAAAAAABBCCDDDEEEEEEEEEEEEEEEFFGGHHIIIIIIIIJKLLLLLMMMNNNNNNOOOOOOPPQRRRRRRSSSSSSTTTTTTUUUUUUVVWXYZ")
S = Solveur(G,g,"LEONNAF",V,P,7)
S.cherche()
S.tri_solutions()
g.placer_mot(S.trouves[0][0],S.trouves[0][1])
print(g)
print(len(S.trouves))
